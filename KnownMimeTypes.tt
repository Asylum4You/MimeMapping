<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension="cs" #>
using System;
using System.Collections.Generic;

namespace MimeMapping
{
<#
    const string APACHE_URL = "http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types";
    const string NGINX_URL = "https://raw.githubusercontent.com/h5bp/server-configs-nginx/master/mime.types";
#>
	///<summary>
	/// MIME type constants. Last updated on <#= DateTime.UtcNow.ToString("s") + "Z" #>. 
	/// Generated from the <a href="<#= APACHE_URL #>">apache</a> and <a href="<#= NGINX_URL #>">nginx</a> sources
	///</summary>
    public static class KnownMimeTypes
    {

<#
		Regex rgx = new Regex("[^a-zA-Z0-9]");

		string GetMimeFieldName(string mimeKey)
		{
			var result = rgx.Replace(mimeKey[0].ToString().ToUpperInvariant() + mimeKey.Substring(1), "");
			return char.IsDigit(result[0]) ? ("_" + result) : result;
		}

		List<string[]> GetMimeTypesFromText(string url, Func<string, string[]> processLine)
        {
			var keyPairs = new List<string[]>();
			using (var responseStream = WebRequest.CreateHttp(url).GetResponse().GetResponseStream())
			using (var streamReader = new StreamReader(responseStream, Encoding.UTF8))
			{
				var response = streamReader.ReadToEnd();
				var lines = response.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
				foreach(var line in lines)
				{
					var newKeyPairs = processLine(line);
					if(newKeyPairs != null) 
						keyPairs.Add(newKeyPairs);
				}
			}
			return keyPairs;
        }

        var entries = new List<string[]>();

		entries.AddRange(GetMimeTypesFromText(APACHE_URL, (line) => {
			if (line[0] == '#') return null;
			var parts = line.Split(new char[0], StringSplitOptions.RemoveEmptyEntries);
			if (parts.Length < 2) return null;
			return parts;
		}));

		entries.AddRange(GetMimeTypesFromText(NGINX_URL, (line) => {
			line = line.Trim().TrimEnd(';');
			if (line[0] == '#' || line[0] == '}' || line.StartsWith("types {")) return null;
			var parts = line.Split(new char[0], StringSplitOptions.RemoveEmptyEntries);
			if (parts.Length < 2) return null;
			return parts;
		}));

		// build dictionary from entries, outputing found duplicates
		var _dict = new Dictionary<string, string>();
		var _reverseDict = new Dictionary<string, List<string>>();

		foreach (var parts in entries)
		{
			for (var i = 1; i < parts.Length; i++)
			{
				string existing;
				if (_dict.TryGetValue(parts[i], out existing))
				{
					if (existing != parts[0])
					{
#>
        // Dupe for <#= parts[i] #>: using <#= existing #> vs <#= parts[0] #> 
<#
					}
				}
				else
				{
					_dict[parts[i]] = parts[0];

					if (!_reverseDict.TryGetValue(parts[0], out var keyList))
					{
						keyList = new List<string>();
						_reverseDict.Add(parts[0], keyList);
					}

					keyList.Add(parts[i]);
				}
			}
		}

#>

		// Generated <#= _reverseDict.Count  #> unique mime type values
        // Generated <#= _dict.Count  #> type key pairs

<#
		// Output constants for each type
        foreach(var kp in _dict)
        {
#>
		///<summary><#= kp.Key #></summary>
        public const string <#= GetMimeFieldName(kp.Key) #> = "<#= kp.Value #>";
<#
		}
#>

<#

		// List constant field names
        foreach (var kp in _dict)
        {
#>
        const string _ext_<#= kp.Key.Replace('-', '_') #> = "<#= kp.Key #>";
<#
		}

#>

        // List of all available extensions, used to build the dictionary
        static internal readonly Lazy<string[]> ALL_EXTS = new Lazy<string[]>(() => new [] {
<#
		// List constant field names
        foreach (var kp in _dict)
        {
#>
            _ext_<#= kp.Key.Replace('-', '_') #>,
<#
		
		}

#>
        });

        // Switch-case instead of dictionary since it does the hashing at compile time rather than run time
        static internal string LookupType(string type)
        {
            switch (type)
            {
<#
                // Output the actual literal C# dictionary
                foreach (var kp in _reverseDict)
                {
					foreach (var mimeKey in kp.Value)
					{
#>
				case _ext_<#= mimeKey.Replace('-', '_') #>:<#
					}
#>
					return <#= GetMimeFieldName(kp.Value[0]) #>;<#
                }
#>
                
				default: 
					return null;
            }
        }
    }
}
